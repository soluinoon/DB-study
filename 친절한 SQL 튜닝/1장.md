# SQL 최적화
SQL 입력 -> 옵티마이저 -> 실행 계획 -> 프로시저
SQL로 입력해도 결국 로우단에서는 절차적으로 실행이 필요하기 때문에 이걸 프로시저라 하고, 옵티마이저가 만들어준다.


# 단계
SQL 파싱 -> SQL 최적화 -> 로우 소스 생성(프로시저 생성)


# 비용
- 옵티마이저는 여러 실행계획을 결정트리로 만들고, 비용이 가장 낮은걸 선택함.
- 비용은 여러 이유로 달라진다 (CPU 상태, 인덱스 등)
- 힌트를 통해 어떤 인덱스를 쓸지, 어떻게 조인할건지 등을 정해서 실행계획을 직접 정할 수 있음.


# SQL 공유 및 재사용
- SQL도 캐싱이 된다. (캐시히트 -> 소프트 파싱, 공유 버퍼)
- SQL 쿼리문 그 자체가 키가돼서 SQL이 조금만 달라져도 하드 파싱이 돼버림.

```sql
select * from emp
select * from EMP
select * from A.emp
...

# 모두 다르게 인식
```
- 하드 파싱은 CPU를 사용
- 따라서 바인드 변수를 통해 파라미터 드리븐으로 소프트 파싱을 사용하는게 중요함.
  
`여기서 바인드 변수를 통해 파라미터 드리븐으로 하는게 자동으로 설정되나? Spring의 캐시 거는 것과 비교해보자.`
